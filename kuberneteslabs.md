# AKS Introduction and Objects

## Table of Contents

[Overview](#overview)

[Pre-Requisites](#pre-requisites)

[Recommended Learning Assets](#recommended-learning-assets)

[Practice 1: Namespaces](#practice-1-namespaces)

[Practice 2: Pods](#practice-2-pods)

[Practice 3: Services](#practice-3-services)

[Practice 4: ConfigMaps](#practice-4-configMaps)

[Practice 5: Secrets](#practice-5-secrets)

[Practice 6: Deployments](#practice-6-deployments)


## Overview

Azure Kubernetes Service (AKS) is a managed container orchestration service to deploy and manage containerized applications. It is based on the open source Kubernetes system, which is available on the Microsoft Azure public cloud. The Kubernetes masters are managed by Azure and the agent nodes (workers) is managed by the users. As it is managed service AKS is free, you only need to pay for agent nodes.Azure Kubernetes Service (AKS) can be created in the Azure Portal, with the Azure Cli or using ARM Templates and Terrform.

Kubernetes Objects are persistent entities in the cluster. These objects are used to represent the state of the cluster. In this Lab we are going discuss about the following Kubernetes Objects.

## Practice 1: Namespaces 

In kubernetes namespace is to categorize objects in a cluster.Namespace can be seggregate your cluster for multiple dev teams for discrete purposes(eg.dev, stage and prod).There are three diffferent namespaces will be created by default. Verify it by using the following command to shows default namespaces in the cluster.

  `kubectl get ns`

  ```
    NAME            STATUS    AGE
    default         Active    154d
    kube-public     Active    154d
    kube-system     Active    154d 
  ```
  
**default:** when you create and run any manifest files in a cluster, by default kubectl command line-tool interacts with the default namespace.

**kube-system:** kube-system namespace is for objects generated by the kubernetes.usually this contains a pods like `kube-dns`, `kube-proxy`, `kubernetes-dashboard`.
  
  `kubectl -n kube-system get po`
 
  ```
    NAME                                    READY     STATUS    RESTARTS   AGE
    kube-proxy-x8p6w                        1/1       Running   0          39d
    kube-dns-bdcc8c4bb-nmn4b                3/3       Running   0          10d
    kubernetes-dashboard-6c45b65444-nvs9p   1/1       Running   0          48d
  ```
**kube-public**: kube-public namespace is automatically created, when you creats a cluster (as like default, kube-system). This content is accessible for the public unauthenticated users. It is mainly uses for system usage.
  
### Create the namespace

1. To create the namespace with respect to the cluster, use the following command or manifest file to create it.
 
  `kubectl create ns <namespace-name>`

**Note:** Here test is used to create the namespace.

  ```
  namespace/test created
  ```

2. Create the namespace by using a manifest file(namespace.yml). 

  ```
  apiVersion: v1
  kind: Namespace
  metadata:
    name: <namespace-name>
    labels:
      name: demo
  ```
3. Create a Namespace by using `kubectl` command line-tool.

  `kubectl create -f C:\Users\Documents\Labs-Kube\namespace.yml`

  ```
  namespace/test created
  ```
 
4. Check by using `kubectl get ns` listout the all namespaces in a cluster. 
 
  `kubectl get ns`
  
  ```
  NAME            STATUS    AGE
  default         Active    154d
  kube-public     Active    154d
  kube-system     Active    154d
  test            Active    2m
  ```
### Delete the namespace

1. To delete the namespace use by the following command to delete namespace.

  `kubectl delete ns <namespace-name>`

  ```  
  namespace "test" deleted
  ```
## Practice 2: Pods

Pod is a collection of application containers and volumes running in a same environment.Pods, not containers, are the smallest deployable artifacts in a kubernetes cluster. Which means all of the containers in a pod always launch on same machine.

### Creata a pod

1. Pod manifests can be written using YAML or JSON, but YAML is usually preferred because it is human-editable, and it has ability to add comments.

2. Pod manifests includes a couple of key fields and attributes.
   * Mostly metadata section for describing the pod and its lables, a spec section is its labels, for describing volumes, images, container port, imagepullsecrets and many more, a list of containers that will run in the Pod.

3. Create a namespace using `kubectl create ns <namespace-name>`.

4. Below YAML is used to create the pod, keep the nampespace name in the YAML.

5. Save the pod YAML file and deploy it using `kubectl create -f <file path>`

  ```
  apiVersion: v1
  kind: Pod
  metadata:
    name: testpod
    namespace: <namespace-name>
  spec:
    containers:
    - image: nginx
      name: testcontainer
      ports:
      - containerPort: 80 
  ```
4. The pod manifest will be submitted to the kubernetes API server.

5. The kubernetes system will then schedule that pod to run on a healthy node in the cluster, where it will be monitored by kubelet daemon process.

### Get the pods

1. List out the pods running in a namespace, by using a following command.

  Ex: `kubectl -n <namespace-name> get pods`

  `kubectl -n <namespace-name> get pods`

  ```
  NAME      READY     STATUS    RESTARTS   AGE
  testpod   1/1       Running   0          4m
  ```

2. You can see the name of pod (testpod) that gave it in previous YAML file. In addition to that number of ready containers, the output also shows the status, the number of times pod was restarted, as well as the age of the pod.

### Describe the Pod details

1. To findout more information about a pod(or any kubernetes object), use kubectl describe command.

  `kubectl -n <namespace-name> describe po testpod`
  
  ```
  Name:               testpod
  Namespace:          test
  Priority:           0
  PriorityClassName:  <none>
  Node:               10.0.1.2/10.0.1.2
  Start Time:         Thu, 09 May 2019 14:59:57 +0530
  Labels:             <none>
  Annotations:        <none>
  Status:             Running
  IP:                 10.244.2.212
  Containers:
    testcontainer:
      Container ID:   docker://ac817bc882ee3e4171dad8a22dde752b247dba910d4f5707e9456ce743714333
      Image:          nginx
      Image ID:       docker-pullable://nginx@sha256:1d0dfe527f801c596818da756e01fa0e7af4649b15e
      Port:           80/TCP
      Host Port:      0/TCP
      State:          Running
        Started:      Thu, 09 May 2019 15:00:06 +0530
      Ready:          True
      Restart Count:  0
      Environment:    <none>
      Mounts:
        /var/run/secrets/kubernetes.io/serviceaccount from default-token-qckb2 (ro)
  Conditions:
    Type              Status
    Initialized       True
    Ready             True
    ContainersReady   True
    PodScheduled      True
  Volumes:
    default-token-qckb2:
      Type:        Secret (a volume populated by a Secret)
      SecretName:  default-token-qckb2
      Optional:    false
  QoS Class:       BestEffort
  Node-Selectors:  <none>
  Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                  node.kubernetes.io/unreachable:NoExecute for 300s
  Events:
    Type    Reason     Age   From               Message
    ----    ------     ----  ----               -------
    Normal  Scheduled  6m    default-scheduler  Successfully assigned test/testpod to 10.0.1.2
    Normal  Pulling    6m    kubelet, 10.0.1.2  pulling image "nginx"
    Normal  Pulled     6m    kubelet, 10.0.1.2  Successfully pulled image "nginx"
    Normal  Created    6m    kubelet, 10.0.1.2  Created container
    Normal  Started    6m    kubelet, 10.0.1.2  Started container
  ```

2. Add the -o wide to any kubectl command, it will printout the slightly more information.

  `kubectl -n <namespace-name> get po testpod -o wide`

  ```
  NAME      READY     STATUS    RESTARTS   AGE       IP            NODE       NOMINATED NODE
  testpod   1/1       Running   0          43h       10.244.1.77   10.0.0.2   <none>
  ```

### Logs of the pod

1. Kubectl logs command downloads the current logs from the running instance.

2. Adding `-f` flag will allow to continuously stream logs.

  `kubectl -n <namespace-name> logs testpod`

### Running Commands in a Container with exec

1. Execute the commands in the conditions of container itself. Get an interactive session by adding the `-it` flag.

  `kubectl -n <namespace-name> exec -it testpod bash`

2. If you want to install packages or resources like (ps-ef, curl) into a container.

  `root@testpod:/# apt-get update`
  `root@testpod:/# apt-get install curl`
  `root@testpod:/#  apt-get update && apt-get install -y procps `


### Edit the pod

1. Edit a pod using a below command, this will popup a pod file, if any addition to pod file add to here. If any changes made, this pod will restart. 

  `kubectl -n <namespace-name> edit po testpod`
 
  ```
  Edit cancelled, no changes made
  ```
 
### Delete the pod

* To delete a pod, can delete it either by name or same file used to create it.
* When a Pod is deleted, it is not immediately killed. Instead, if run kubectl get pods, will see that the Pod is in the Terminating state.

  `kubectl -n <namespace-name> delete po testpod`

  ```
  pod "testpod" deleted`
  ```

## Practice 3: Services

A Service is a Kubernetes object used to define a logical set of **Pods** and also create a policy by which other service can access them. The logical set of pods that is under a service is determined by a **Label Selector**.

**Types of Services**

1. ClusterIp
2. NodePort
3. LoadBalancer
4. ExternalName
5. ExternalIPs

### ClusterIP

ClusterIP service is a default service type in kubernetes cluster. It exposes the service on a cluster-internal IP. This type of service are reachable from within the cluster. Below is code for a clusterIP type service, use the command `kubectl create -f <filename-name>` to deploy the service.

  ```
  apiVersion: v1
  kind: Service
  metadata:
    name: test-service
    labels:
      service-name: test-service
  spec:
    ports:
      - name: tcp-8089
      protocol: TCP
      port: 8089
      targetPort: 8089
    selector:
      service-name: test-service

  ```

### NodePort

NodePort type of service exposes the service on each node's IP at a static port. One can access a NodePort type service from outside of the cluster, by accessing the <NodeIP>:<StaticPort>. Below is code for a NodePort type service, use the command `kubectl create -f <filename-name>` to deploy the service.

  ```
  apiVersion: v1
  kind: Service
  metadata:
    name: test-service
    labels:
      service-name: test-service
  spec:
    type: NodePort
    ports:
      - name: tcp-8089
      protocol: TCP
      port: 8089
      targetPort: 8089
    selector:
      service-name: test-service
  ```

### LoadBalancer

LoadBalancer type of service exposes the service externally using a cloud provider's Load Balancer resource (ie Azure Load Balancer in AKS, Elastic Load Balancer in Amazon EKS). One can access a LoadBalancer type service from outside of the cluster, by accessing the <LoadBalancerPublicIP>:<Port>. Below is code for a LoadBalancer type service, use the command `kubectl create -f <filename-name>` to deploy the service.

  ```
  apiVersion: v1
  kind: Service
  metadata:
    name: test-service
    labels:
      service-name: test-service
  spec:
    type: LoadBalancer
    loadBalancerIP: <replace-with-IP-of-LB>
    ports:
      - name: tcp-8089
      protocol: TCP
      port: 8089
      targetPort: 8089
    selector:
      service-name: test-service
  ```

## 4. ExternalName

ExternalName type of the service maps the service to the contents of the externalName field, by returning a CNAME record with its vault. This type of service requires version 1.7 or higher of **kube-dns**. Below is code for a ExternalName type service, use the command `kubectl create -f <filename-name>` to deploy the service.

  ```
  kind: Service
  apiVersion: v1
  metadata:
    name: test-service
    labels:
      service-name: test-service
  spec:
    type: ExternalName
    externalName: test-service.example.com
  ```


### ExternalIPs

If there are ExternalIP's that route traffic to the cluster nodes, then kubernetes services can be exposed on those **externalIPs**. Traffic that ingresses into the cluster with the external IP (as destination IP), on the service port, will be routed to one of the service endpoints. In the **ServiceSpec**, **externalIPs** can be specified along with any of the **ServiceTypes**. In the example below, db-service can be accessed by client on the IP

  ```
  kind: Service
  apiVersion: v1
  metadata:
    name: db-service
  spec:
    selector:
      service-name: db-service
    ports:
    - name: http
      protocol: TCP
      port: 28015
      targetPort: 28015
    externalIPs:
    - <replace-with-external-service-IP-address>
  ```

### Get list of services

To get a service use the command `kubectl -n <namespace-name> get services`

  ```
  NAME            TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE
  test-service    ClusterIP   10.96.235.1   <none>        8089/TCP   5d
  ```

### Describe a service

To get a service use the command `kubectl -n <namespace-name> describe service <service-name>`

  ```
  Name:              test-service
  Namespace:         test-service
  Labels:            service-name=test-service
  Annotations:       <none>
  Selector:          service-name=test-service
  Type:              ClusterIP
  IP:                10.96.235.1
  Port:              <unset>  8089/TCP
  TargetPort:        8089/TCP
  Endpoints:         <none>
  Session Affinity:  None
  Events:            <none>
  ```

### Edit a Service

To edit a Service resource in a namespace use the command `kubectl -n <namespace-name> edit service <service-name>`

The currently deployed service resource YAML will be opened in a text editor and you can edit as per the requirement then save the file, this will update the service resource successfully. Make sure the YAML syntax is followed.


### Delete a service

To delete a service use the command `kubectl -n <namespace-name> delete service <service-name>`

This will delete the service resource.

## Practice 4: ConfigMaps

ConfigMaps are used to provide configuration information for containarized workloads, it is a kubernetes object that defines small filesystem.Other way set of variables that can be used when defining
the environment or command line for your containers.
The basic thing is that the ConfigMap is combined with the Pod right before it is run, means that the container image and the pod definition itself can be reused across many apps by just changing the ConfigMap that is used.

### Create a ConfigMaps

1. Using a configMap there are three main ways to use configMaps:

  **Filesystem:**
      can mount into a pod. A file is created for each entry based on the key name. The content of the file is set to value.
      
  **Environment variable:**
      ConfigMap can be used to dynamically set the value of an Environment variable.
      
  **Command-line argument:**
      Kubernetes supports dynamically creating the command line for a container based on ConfigMap values.

2. Create a configMap with a filename `test-cm.yml`, by using a following command.

  `kubectl -n <namespace> apply -f test-cm.yml`

  ```
  kind: ConfigMap 
  apiVersion: v1 
  metadata:
    name: test-cm
  data:
    # Configuration values can be set as key-value properties
    database: mongodb
    database_uri: mongodb://localhost:27017
    
    # Or set as complete file contents (even JSON!)
    keys: | 
      image.public.key=771 
      rsa.public.key=42
  ```
### Get the ConfigMaps

  `kubectl -n <namespace-name> get cm`

  ```
  NAME             DATA      AGE
  test-cm          3         23s
  ```

### Describe the Configmap

  `kubectl -n <namespace-name> describe cm test-cm`
 
  ```
  Name:         test-cm
  Namespace:    labs-sidda
  Labels:       <none>
  Annotations:  kubectl.kubernetes.io/last-applied-configuration={"apiVersion":"v1","data":{"database":"mongodb","database_uri":"mongodb://localhost:27017","keys":"image.public.key=771 \nrsa.public.key=42\n"},"kind":...

  Data
  ====
  keys:
  ----
  image.public.key=771
  rsa.public.key=42

  database:
  ----
  mongodb
  database_uri:
  ----
  mongodb://localhost:27017
  Events:  <none>

  ```

### Access the ConfigMaps from pods

1. Create a pod with a filename `sample-pod.yml`,to pull Environmental variables from the Configmaps.

2. Environmental variables are mentioned with a envFrom member.This references the ConfigMap and the data key to use within that ConfigMap.

3. Use the following command to create a pod.

  `kubectl -n <namespace-name> apply -f sample-pod.yml`
  ```
    apiVersion: v1
    kind: Pod 
    metadata:
      name: sample-pod 
    spec:
      containers: 
        - envFrom:
          - configMapRef:
              name: test-cm
          name: test-container
          image: iad.ocir.io/jumpstart/nginx:1.15 
          imagePullPolicy: Always
          ports:
          - containerPort: 80 
      imagePullSecrets:
      - name: shaoketest
      
  ```
4. After created the Pod, you will be able to access these environment variables, by using the following command.

  `kubectl -n <namespace-name> exec -it sample-pod sh`
  
  ```
  # env
  KUBERNETES_PORT=tcp://10.96.0.1:443
  KUBERNETES_SERVICE_PORT=443
  database=mongodb
  HOSTNAME=sample-pod
  database_uri=mongodb://localhost:27017
  HOME=/root
  keys=image.public.key=771
  rsa.public.key=42

  TERM=xterm
  KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
  NGINX_VERSION=1.15.12-1~stretch
  PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
  KUBERNETES_PORT_443_TCP_PORT=443
  NJS_VERSION=1.15.12.0.3.1-1~stretch
  KUBERNETES_PORT_443_TCP_PROTO=tcp
  KUBERNETES_SERVICE_PORT_HTTPS=443
  KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
  KUBERNETES_SERVICE_HOST=10.96.0.1
  PWD=/
  ```

### Edit the ConfigMap

  `kubectl -n <namespace-name> edit cm test-cm`


### Delete the ConfigMap
 
  `kubectl -n <namespace-name> delete cm test-cm`
 
  ```
  configmap "test-cm" deleted
  ```

## Practice 5: Secrets

* Secrets are the small objects in kubernetes, that contains sensitive information such as credentials, tokens. They are stored in `etcd`, these accessible by kubernetes API server and it can be mounted as files into a pod, that pod needs to be access them. The same secret can be mounted into multiple pods.
* Another perspective of is to use secret as Environmental variables. Secrets in a pod always stored in a memory(tmfs-temporary file storage)
* Secrets are created using the Kubernetes API or the kubectl command-line tool.Secrets hold one or more data elements as a collection of key/value pairs.

### Create a secret

There are different ways to create secrets in kubernetes.Use any one of the following ways.

1. create local files using `kubectl` tool.
2. create by using a manifest file of `kind:secret`.
    
### Create the Secrets from Files using Kubectl

1. Create local files with sensitive information like passwords and ssh keys and then convert them into a Secret stored and managed by the Kubernetes API server. Kubernetes will create key-value pairs using the filenames and their contents and encode the sensitive data in `base64` format.

2. Create the files with the username and password on your local machine.

  `echo -n 'test' > ./username.txt`

  `echo -n 'jiki893kdjnsaasdsa' > ./password.txt`

  `kubectl create secret`  command to package files into a Secret and create a Secret API object on the API server.
  
  `kubectl -n <namespace-name> create secret generic db --from-file=/home/documents/username.txt --from-file=/home/documents/password.txt`
 
  ```
  secret "db" created
  ```

### Get the secrets

1. Verify it by using the following command to get the secrets created.

  `kubectl get secrets -n <namespace-name>`
   
  ```
    NAME                  TYPE                                  DATA      AGE
    db                    Opaque                                2         1m
  ```  

### Describe the secrets

1. Describe will shows you detailed information about the seceret, use `kubectl describe`.

  `kubectl describe secrets db -n <namespace-name>`

  ```
  Name:         db-auth
  Namespace:    default
  Labels:       <none>
  Annotations:  <none>
  Type:  Opaque
  Data
  ====
  password.txt:  15 bytes
  username.txt:  5 bytes
  ```
2. The `type:Opaque` refers to the Secret means that from Kubernetes point of view the contents of the Secret is unstructured.

### Edit the Secrets

* Edit the secrets by using a following command, will popup a file to edit any changes. 

  `kubectl edit secrets <secretname> -n <namespace-name>`


### Create a Secret for Azure Container Registry

1. Create a secret for Azure Container Registry (ACR) to push and pull the docker images.

  `kubectl create secret docker-registry <secret-name> --docker-server=<acr registry url> --docker-username=<username> --docker-password=<password> --docker-email=<email id> -n <namespace-name>`

2. List out the secrets by using following command.

  `kubectl get secrets -n <namespace-name>`

### Access the secrets from the pod (test-pod.yml)

1. Use the created secrets in the pod yaml and access the secrets.

  ```
  apiVersion: v1
  kind: Pod 
  metadata:
    name: sample-pod 
  spec:
    containers: 
      - envFrom:
        - configMapRef:
            name: test-cm
        name: test-container
        image: <docker-image-name>
        imagePullPolicy: Always
        ports:
        - containerPort: 80 
      secret:
              defaultMode: 420
              secretName: <db-secret-name>  
    imagePullSecrets:
    - name: <acr-secret-name>
  ```

## Practice 6: Deployments

A deployment is a supervisor for pods, it provides declarative updates for Pods and ReplicaSets.
A ReplicaSet’s purpose is to maintain a stable set of replica Pods running at any given time.

### Create a Deployment

1. Create a deployment that creates a replicaset to bring up three nginx pods.

2. You can create the deployment in a particular namespace or it will deploy in the default namespace. Save the YAML file and create using `kubectl create -f <file path>`

3. Create a namespace using `kubectl create ns <namespace-name>`

  ```
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment
    namespace: <namespace-name>
    labels:
      app: nginx
  spec:
    replicas: 3
    selector:
      matchLabels:
        app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
        - name: nginx
          image: nginx:1.7.9
          ports:
          - containerPort: 80
  ```

3. Get the deployment using `kubectl -n <namespace-name> get deployments`

  ```
  NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
  nginx-deployment   3         3         3            3           4m
  ```

4. A Deployment named nginx-deployment is created, indicated by the .metadata.name field.

5. The Deployment creates three replicated Pods, indicated by the replicas field.

6. The selector field defines how the Deployment finds which Pods to manage. In this case, you simply select a label that is defined in the Pod template (app: nginx). However, more sophisticated selection rules are possible, as long as the Pod template itself satisfies the rule.

7. Get the pods in nginx deployment using `kubectl -n <namespace-name> get pods`

  ```
  NAME                                READY     STATUS    RESTARTS   AGE
  nginx-deployment-5c689d88bb-5h7vx   1/1       Running   0          9m
  nginx-deployment-5c689d88bb-mbqzg   1/1       Running   0          9m
  nginx-deployment-5c689d88bb-txdj7   1/1       Running   0          9m
  ```

### Updating a Deployment

1. If you want to edit the existing deployment you can use `kubectl -n <namespace-name> edit deployment <deployment-name>`
